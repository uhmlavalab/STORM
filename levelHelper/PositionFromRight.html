<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<link rel="icon" href="favicon.ico">
		<title>Main Page</title>
	</head>
	<!-- ===================================================================================================================== Body -->
	<body onload="main()">


		<div id='topdiv'> </div>
		<div id='resultDiv'> </div>



		<!-- JavaScript references placed at the end of the document so the pages load faster -->
		<script type="text/javascript" src="../js/globals.js"></script>

		<script type="text/javascript">
		function main() {
			generateStartOfVarDeclare();

			var endOfPhase;

			generateIntroText();
			endOfPhase = generateP1SiFormation( 8000 ); //unfortunately hard coded for now
			endOfPhase = generateP2Snaking(endOfPhase);
			endOfPhase = generateP3Shapes(endOfPhase);

			generateEndBrace();
		}

		/**
		=============================================================================
		=============================================================================
		=============================================================================
		*/
		function generateP3Shapes(endOfP2) {
			var startTime = endOfP2;
			var topdiv = document.getElementById("topdiv");
			var contents = "";

			var rObj;
			rObj = genP3Pong( startTime );
				contents += rObj.contents;
				startTime = rObj.lastDeathTime;
			
			rObj = genP3Pacman( startTime + 2000 );
				contents += rObj.contents;
			topdiv.innerHTML += contents;


			// rObj = gp3SetupPacmanLocations();
			// topdiv.innerHTML += rObj.doubleCheckPattern

			return startTime;
		} //end generateP3Shapes

		function genP3Pacman(p3PacmanStartTime) {
			var rObj = {};
				rObj = gp3SetupPacmanLocations();
				rObj.lastDeathTime = p3PacmanStartTime;
				rObj.contents = "";
				rObj.pacmanSize = 15;
			var totalPacmanPieces = 169;
			var tx, ty, timeReference;

			//timeReference = p3PacmanStartTime;



			//for each pacman pieces, tripple layer
			for( var i = 0; i < totalPacmanPieces * 2; i++) {

				indexToUse = i % totalPacmanPieces;
				timeReference = p3PacmanStartTime;

				tx = cCanvasWidth * parseInt( Math.random() * 3); //0,1,2 then turns into 0,cCanvasWidth
				//if lands on twice width, then set it to a value within the width.
				if(tx > cCanvasWidth) {
					tx = parseInt( Math.random() * cCanvasWidth);
					ty = cCanvasHeight * parseInt( Math.random() * 2); 
				}
				else {
					ty = parseInt( Math.random() * cCanvasHeight); //0, cCanvasHeight
				}
				//first spawn
				rObj.contents += returnSpawnEntry( timeReference, tx, ty  );
				//form pacman on the right
				timeReference += 2000;
				rObj.contents += gp3GetPacmanMoveToByLocation(rObj, timeReference, cCanvasWidth - rObj.pacmanSize * cEn1Width, cCanvasHeight/2 - rObj.pacmanSize/2 * cEn1Width, indexToUse, false  );


				for(var a = 0; a < 10; a++) {
					//halt with closed mouth
					timeReference += 3000;
					rObj.contents += returnHaltUntilEntry(timeReference);
					//open mouth
					rObj.contents += gp3GetPacmanMoveToByLocation(rObj, timeReference, cCanvasWidth - rObj.pacmanSize * cEn1Width, cCanvasHeight/2 - rObj.pacmanSize/2 * cEn1Width, indexToUse, true  );
					
					//special case shooting
					if( i === 84 || i === 85 || i === 86) {
						rObj.contents += returnShootAtTimeEntry( timeReference, "amountOfShots:30,speed:300,target:circleBurst", "100" );
					}

					//
					timeReference += 3000;
					rObj.contents += returnHaltUntilEntry(timeReference);
					//
					rObj.contents += gp3GetPacmanMoveToByLocation(rObj, timeReference, cCanvasWidth - rObj.pacmanSize * cEn1Width, cCanvasHeight/2 - rObj.pacmanSize/2 * cEn1Width, indexToUse, false  );
				}




				//special case shooting
				if ( i === 16) {
					//amountOfShots:10,speed:50,target:circleBurst
					rObj.contents += returnShootIntervalEntry( 1000, "amountOfShots:1,speed:80,target:player", "100" );
				}

			} //end for each invader

			return rObj;
			
		} //end genP3Pacman

		function gp3GetPacmanMoveToByLocation( pacmanLocations, time, x, y, index, openMouth ) {
			var xmod = 0;
			var ymod = 0;
			var timeToBreak = false;

			var layoutToUse = pacmanLocations.layoutClosedMouth;
			if ( openMouth === true ) { layoutToUse = pacmanLocations.layoutOpenMouth; }

			for ( ymod = 0; ymod < layoutToUse.length; ymod++ ) {
				for ( xmod = 0; xmod < layoutToUse[ymod].length; xmod++ ) {
					if( layoutToUse[ymod][xmod] === index ) {
						timeToBreak = true;
						break;
					}
					if( openMouth &&  layoutToUse[ymod][xmod] === -1 * index ) {
						timeToBreak = true;
						xmod += 8;
						break;
					}
				}
				if(timeToBreak) { break; }
			}

			return returnMoveToByEntry(  time,  x + cEn1Width * xmod, y + cEn1Width * ymod);
		} //end gp3GetPacmanMoveToByLocation

		/**
		Currently pacman is 15x15 = 255.
		      ***
		   *********
		  ***********
		 *************
		 *************
		 *************
		***************
		***************
		***************
		 *************
		 *************
		 *************
		  ***********
		   *********
		      ***

		      ***
		   *********
		  ***********
		   ***********
		    **********
		     *********
		      *********
		       ********
		      *********
		     *********
		    **********
		   ***********
		  ***********
		   *********
		      ***

		Given the index, and whether or not the mouth is open, where should a particular invader be?



		*/
		function gp3SetupPacmanLocations() {
			var a = -999;
			var b = -1;
			var layoutClosedMouth = [
							[a,a,a, 	a,a,a,		b,b,b,		a,a,a, 		a,a,a],	//0
							[a,a,a,		b,b,b, 		b,b,b, 		b,b,b, 	 	a,a,a],	//1
							[a,a,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,a,a],	//2
							[a,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,a], //3
							[a,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,a], 
							[a,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,a], 
							[b,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,b], 
							[b,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,b], 
							[b,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,b], 
							[a,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,a], 
							[a,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,a], 
							[a,b,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,b,a], 
							[a,a,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,a,a],
							[a,a,a,		b,b,b, 		b,b,b, 		b,b,b, 	 	a,a,a],
							[a,a,a, 	a,a,a,		b,b,b,		a,a,a, 		a,a,a]
						];
			var layoutOpenMouth = [
							[a,a,a, 	a,a,a,		b,b,b,		a,a,a, 		a,a,a],	//0
							[a,a,a,		b,b,b, 		b,b,b, 		b,b,b, 	 	a,a,a],	//1
							[a,a,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,a,a],	//2
							[a,a,a,		b,b,b, 		b,b,b, 		b,b,b, 	 	b,b,a],
							[a,a,a, 	a,b,b, 		b,b,b, 		b,b,b, 	 	b,b,a],
							[a,a,a, 	a,a,b, 		b,b,b, 		b,b,b, 	 	b,b,a],

							[a,a,a, 	a,a,a, 		b,b,b, 		b,b,b, 	 	b,b,b],
							[a,a,a, 	a,a,a, 		a,b,b, 		b,b,b, 	 	b,b,b],
							[a,a,a, 	a,a,a, 		a,b,b, 		b,b,b, 	 	b,b,b],

							[a,a,a, 	a,a,b, 		b,b,b, 		b,b,b, 	 	b,b,a],
							[a,a,a, 	a,b,b, 		b,b,b, 		b,b,b, 	 	b,b,a],
							[a,a,a,		b,b,b, 		b,b,b, 		b,b,b, 	 	b,b,a],
							[a,a,b, 	b,b,b, 		b,b,b, 		b,b,b, 		b,a,a],
							[a,a,a,		b,b,b, 		b,b,b, 		b,b,b, 	 	a,a,a],
							[a,a,a, 	a,a,a,		b,b,b,		a,a,a, 		a,a,a]
						];
			var indexTracker = 0;

			for ( var h = 0; h < layoutClosedMouth.length; h++ ) {
				for ( var w = 0; w < layoutClosedMouth[h].length; w++ ) {
					if ( layoutClosedMouth[h][w] === b ) {
						layoutClosedMouth[h][w] = indexTracker;
						indexTracker++;
					}
				}
			}
			for ( var h = 0; h < layoutOpenMouth.length; h++ ) {
				for ( var w = 0; w < layoutOpenMouth[h].length; w++ ) {
					if ( layoutOpenMouth[h][w] === a && layoutClosedMouth[h][w] !== a ) {
						layoutOpenMouth[h][w] = -1 * layoutClosedMouth[h][w];
					}
					else {
						layoutOpenMouth[h][w] = layoutClosedMouth[h][w];
					}
				}
			}

			var rObj = {};
				rObj.layoutClosedMouth = layoutClosedMouth;
				rObj.layoutOpenMouth = layoutOpenMouth;
				rObj.doubleCheckPattern = "";

			for ( var h = 0; h < layoutClosedMouth.length; h++ ) {
				for ( var w = 0; w < layoutClosedMouth[h].length; w++ ) {
					rObj.doubleCheckPattern += layoutClosedMouth[h][w];
				}
				rObj.doubleCheckPattern += "<br>";
			}
			rObj.doubleCheckPattern += "<br>";
			rObj.doubleCheckPattern += "<br>";
			for ( var h = 0; h < layoutOpenMouth.length; h++ ) {
				for ( var w = 0; w < layoutOpenMouth[h].length; w++ ) {
					rObj.doubleCheckPattern += layoutOpenMouth[h][w];
				}
				rObj.doubleCheckPattern += "<br>";
			}

			return rObj;
		} //end 


		function genP3Pong(p3PongStartTime) {
			var paddle = {};
				paddle.height = 2;
				paddle.width = 12;
				paddle.stackHeight = 3;
			var ball = {};
				ball.width = 3;
				ball.height = 3;
				ball.stackHeight = 3;

			var content = "";
			var rObj = {};

			paddle.topIndexStart 	= 0;
			paddle.topIndexEnd 		= paddle.height * paddle.width * paddle.stackHeight -1;
			paddle.bottomIndexStart = paddle.topIndexEnd + 1;
			paddle.bottomIndexEnd 	= paddle.bottomIndexStart + paddle.topIndexEnd;
			ball.indexStart 		= paddle.bottomIndexEnd + 1;
			ball.indexEnd 			= ball.indexStart + (ball.width * ball.height * ball.stackHeight) -1 ;

			paddle.topM1x			= cCanvasWidth/3;
			paddle.topM1y 			= cEn1Width;
			paddle.topM2x			= cCanvasWidth - (cEn1Width * paddle.width) - cEn1Width;
			paddle.topM2y 			= cEn1Width;
			paddle.topM3x			= cCanvasWidth/3;
			paddle.topM3y 			= cEn1Width;
			paddle.topM4x			= cCanvasWidth - (cEn1Width * paddle.width) - cEn1Width;
			paddle.topM4y 			= cEn1Width;
			paddle.bottomM1y 		= cCanvasHeight - (cEn1Width * 2) - (paddle.height * cEn1Width);

			ball.m1x 				= paddle.topM1x +  (ball.width * cEn1Width / 2);
			ball.m1y 				= paddle.bottomM1y + cEn1Width - (ball.height * cEn1Width);
			ball.m2x 				= paddle.topM2x + (ball.width * cEn1Width);
			ball.m2y 				= paddle.topM2y + (cEn1Width * paddle.height);
			ball.m3ax 				= cCanvasWidth - (ball.width * cEn1Width);
			ball.m3ay 				= cCanvasHeight / 3;
			ball.m3bx 				= paddle.topM3x + (cEn1Width * paddle.width/ 4 * 3) - (ball.width * cEn1Width / 2);
			ball.m3by 				= paddle.bottomM1y + cEn1Width  - (ball.height * cEn1Width);
			ball.m4ax 				= cCanvasWidth / 4 * 3;
			ball.m4ay 				= paddle.topM2y + (cEn1Width * paddle.height);
			ball.m4bx 				= cCanvasWidth - (ball.width * cEn1Width);
			ball.m4by 				= cCanvasHeight + cEn1Width;

			var m1TimeToGetToPositionBy = 2000 + p3PongStartTime;
			var m2PaddleLeftToRight = 3000 + m1TimeToGetToPositionBy;
			var m3aBallBounceOffRight = 1000 + m2PaddleLeftToRight;
			var m3PaddleRightToLeft = 3000 + m2PaddleLeftToRight;
			var m4aBallBounceAroundMid = 1500 + m3PaddleRightToLeft;
			var m4bBallFallThrough = 2500 + m3PaddleRightToLeft;
			var m4PaddleLeftToRight = 3000 + m3PaddleRightToLeft;
			var m5Pause = 1000 + m4PaddleLeftToRight;
			var m6MoveOffScreen = 1000 + m5Pause;

			var lastDeathTime = m6MoveOffScreen;

			//top paddle

			for ( var i = paddle.topIndexStart; i <= paddle.topIndexEnd; i++ ) {
				//first spawn just off the right side of the screen in a random y position.
				content += returnSpawnEntry( p3PongStartTime, cCanvasWidth + cEn1Width, parseInt( Math.random() * cCanvasHeight ) );

				content += returnShootIntervalEntry( 1000, "amountOfShots:1,speed:80,target:player", 6);
				//get to formation start m1.
				content += returnMoveToByEntry(
								m1TimeToGetToPositionBy, 
								paddle.topM1x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.topM1y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m2
				content += returnMoveToByEntry(
								m2PaddleLeftToRight, 
								paddle.topM2x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.topM2y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m3
				content += returnMoveToByEntry(
								m3PaddleRightToLeft, 
								paddle.topM3x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.topM3y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m4
				content += returnMoveToByEntry(
								m4PaddleLeftToRight, 
								paddle.topM4x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.topM4y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m5
				content += returnHaltUntilEntry( m5Pause );
				//m6
				content += returnMoveToByEntry(
								m6MoveOffScreen, 
								paddle.topM4x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								(-1 * cEn1Width * (paddle.height + 1)) + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				content += returnDieAtByEntry( m6MoveOffScreen );
			}

			//bottom paddle

			for ( var i = paddle.bottomIndexStart; i <= paddle.bottomIndexEnd; i++ ) {
				//first spawn just off the right side of the screen in a random y position.
				content += returnSpawnEntry( p3PongStartTime, cCanvasWidth + cEn1Width, parseInt( Math.random() * cCanvasHeight ) );

				content += returnShootIntervalEntry( 1000, "amountOfShots:1,speed:80,target:player", 6);
				//get to formation start m1.
				content += returnMoveToByEntry(
								m1TimeToGetToPositionBy, 
								paddle.topM1x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.bottomM1y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m2
				content += returnMoveToByEntry(
								m2PaddleLeftToRight, 
								paddle.topM2x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.bottomM1y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m3
				content += returnMoveToByEntry(
								m3PaddleRightToLeft, 
								paddle.topM3x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.bottomM1y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m4
				content += returnMoveToByEntry(
								m4PaddleLeftToRight, 
								paddle.topM4x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								paddle.bottomM1y + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				//m5
				content += returnHaltUntilEntry( m5Pause );
				//m6
				content += returnMoveToByEntry(
								m6MoveOffScreen, 
								paddle.topM4x + cEn1Width * ( parseInt( i/paddle.stackHeight ) % paddle.width ),
								cCanvasHeight + cEn1Width + cEn1Width * ( parseInt( i/paddle.stackHeight/paddle.width ) ) );
				content += returnDieAtByEntry( m6MoveOffScreen );
			}

			//ball

			for ( var i = ball.indexStart; i <= ball.indexEnd; i++ ) {
				//first spawn just off the right side of the screen in a random y position.
				content += returnSpawnEntry( p3PongStartTime, cCanvasWidth + cEn1Width, parseInt( Math.random() * cCanvasHeight ) );
				i -= ball.indexStart;
				//m1
				content += returnMoveToByEntry(
								m1TimeToGetToPositionBy, 
								ball.m1x + ( parseInt( i / 3) % 3 * cEn1Width),
								ball.m1y + ( parseInt( i / 3 / 3) * cEn1Width) );
				//m2
				content += returnMoveToByEntry(
								m2PaddleLeftToRight, 
								ball.m2x + ( parseInt( i / 3) % 3 * cEn1Width),
								ball.m2y + ( parseInt( i / 3 / 3) * cEn1Width) );
				if( 6 === i) {
					content += returnShootAtTimeEntry( m2PaddleLeftToRight, "amountOfShots:60,speed:150,target:circleBurst", "100" );
					}
				//m3a
				content += returnMoveToByEntry(
								m3aBallBounceOffRight, 
								ball.m3ax + ( parseInt( i / 3) % 3 * cEn1Width),
								ball.m3ay + ( parseInt( i / 3 / 3) * cEn1Width) );
				if( 6 === i) {
					content += returnShootAtTimeEntry( m3aBallBounceOffRight, "amountOfShots:60,speed:150,target:circleBurst", "100" );
					}
				//m3b
				content += returnMoveToByEntry(
								m3PaddleRightToLeft, 
								ball.m3bx + ( parseInt( i / 3) % 3 * cEn1Width),
								ball.m3by + ( parseInt( i / 3 / 3) * cEn1Width) );
				if( 6 === i) {
					content += returnShootAtTimeEntry( m3PaddleRightToLeft, "amountOfShots:60,speed:150,target:circleBurst", "100" );
					}
				//m4a
				content += returnMoveToByEntry(
								m4aBallBounceAroundMid, 
								ball.m4ax + ( parseInt( i / 3) % 3 * cEn1Width),
								ball.m4ay + ( parseInt( i / 3 / 3) * cEn1Width) );
				if( 6 === i) {
					content += returnShootAtTimeEntry( m4aBallBounceAroundMid, "amountOfShots:60,speed:150,target:circleBurst", "100" );
					}
				//m4b
				content += returnMoveToByEntry(
								m4bBallFallThrough, 
								ball.m4bx + ( parseInt( i / 3) % 3 * cEn1Width),
								ball.m4by + ( parseInt( i / 3 / 3) * cEn1Width) );
				if( 6 === i) {
					content += returnShootAtTimeEntry( m4bBallFallThrough, "amountOfShots:60,speed:150,target:circleBurst", "100" );
					}
				content += returnDieAtByEntry( m4bBallFallThrough );
				i += ball.indexStart;
			}

			rObj.contents = content;
			rObj.lastDeathTime = lastDeathTime;

			return rObj;
		} //end genP3Pong

		/**
		=============================================================================
		=============================================================================
		=============================================================================
		*/
		function generateP2Snaking( endOfP1 ) {
			var topdiv = document.getElementById("topdiv");
			var contents = "";
			var timePhase2Start = 33950;
			if ( endOfP1 !== undefined && endOfP1 !== null ) {
				timePhase2Start = endOfP1;
			}

			var numberOfWaves = 3;
			var heightOfWaves = cCanvasHeight * 0.20;
			var percentOfHeightStraightWay = 0.7;
			var timeToCompleteWave = 5000;
			var streamSize = 7;
			var streamStartTime = timePhase2Start;
			var streamSpawnDelay = 100;
			//crossstream delay to after the initial stream
			var streamCrossDelayedTime = 0;

			//stream down from middle
			contents += getEntriesForStream(
							streamSize,
							streamStartTime,
							streamSpawnDelay,
							cCanvasWidth,			//xStart
							cCanvasHeight/2,		//yStart
							-cCanvasWidth,			//widthWaveDirection
							numberOfWaves,
							heightOfWaves,
							percentOfHeightStraightWay,
							timeToCompleteWave  );
			//stream up from middle
			contents += getEntriesForStream(
							streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2, -cCanvasWidth, numberOfWaves,
							-heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );

			//delayed cross path

			//crossing path for bottom stream
			contents += getEntriesForStream(
							streamSize,
							streamStartTime, //changed
							streamSpawnDelay, cCanvasWidth,
							cCanvasHeight/2 + heightOfWaves, //changed yStart
							-cCanvasWidth, numberOfWaves,
							-heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );
			//crossing path for bottom stream
			contents += getEntriesForStream(
							streamSize,
							streamStartTime, //changed
							streamSpawnDelay, cCanvasWidth,
							cCanvasHeight/2 - heightOfWaves, //changed yStart
							-cCanvasWidth, numberOfWaves,
							heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );

			//delay by until after first stream wave
			streamStartTime += timeToCompleteWave;

			//bottom cross
			contents += getEntriesForStream(
							streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth,
							cCanvasHeight/2 + heightOfWaves, //changed yStart
							-cCanvasWidth, numberOfWaves,
							heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );
			contents += getEntriesForStream(
							streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth,
							cCanvasHeight/2 + heightOfWaves*2, //changed yStart
							-cCanvasWidth, numberOfWaves,
							-heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );
			//top cross
			contents += getEntriesForStream(
							streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth,
							cCanvasHeight/2 - heightOfWaves, //changed yStart
							-cCanvasWidth, numberOfWaves,
							-heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );
			contents += getEntriesForStream(
							streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth,
							cCanvasHeight/2 - heightOfWaves*2, //changed yStart
							-cCanvasWidth, numberOfWaves,
							heightOfWaves, 		//changed the height
							percentOfHeightStraightWay, timeToCompleteWave  );

			//delay by until after second stream wave
			streamStartTime += timeToCompleteWave;
			timeToCompleteWave = 3500;
			streamSpawnDelay = 300;
			streamSize = parseInt( timeToCompleteWave / streamSpawnDelay);

			//switch to horizontal stream

			//top cross
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2 - heightOfWaves, -cCanvasWidth, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half 
			streamStartTime += timeToCompleteWave;
			//
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2 - heightOfWaves*2, -cCanvasWidth, numberOfWaves, heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half
			streamStartTime += timeToCompleteWave;
			//middle upper
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2, -cCanvasWidth, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half 
			streamStartTime += timeToCompleteWave;
			//
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2 - heightOfWaves, -cCanvasWidth, numberOfWaves, heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half
			streamStartTime += timeToCompleteWave;
			//middle lower
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2, -cCanvasWidth, numberOfWaves, heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half 
			streamStartTime += timeToCompleteWave;
			//
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2 + heightOfWaves, -cCanvasWidth, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half
			streamStartTime += timeToCompleteWave;
			//bottom cross
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2 + heightOfWaves, -cCanvasWidth, numberOfWaves, heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//half 
			streamStartTime += timeToCompleteWave;
			//
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth, cCanvasHeight/2 + heightOfWaves*2, -cCanvasWidth, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );







			// pause between vertical spire
			timeToCompleteWave -= 1000; //one second less than horizontal
			streamStartTime += timeToCompleteWave + 3000;

			for(var i = 0; i < 5; i++) {
				contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasHeight,
					cCanvasWidth - (heightOfWaves * (i+1)),
					-cCanvasHeight, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave, "makeItVertical"  );
				streamStartTime += timeToCompleteWave + streamSpawnDelay * streamSize + 1000;
			}

			streamStartTime += 2000;

			//---------------------------------------------------------------
			//flood the far right vertical
			streamSize = 38;
			streamSpawnDelay = 200;
			//far right starts first
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasHeight,
				cCanvasWidth - heightOfWaves,
				-cCanvasHeight, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave, "makeItVertical"  );
			//setup the middle stream
			streamStartTime += 1000; //2 second delay
			streamSize = 33; //1000/50 = 40
			// //far right starts first
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasHeight,
				cCanvasWidth/2,
				-cCanvasHeight, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave, "makeItVertical"  );
			//setup horizontal
			streamStartTime += 1000;
			timeToCompleteWave += 1000;
			streamSize = 23;
			//bottom hori stream
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth,
				cCanvasHeight / 4 * 3,
				-cCanvasWidth, numberOfWaves, heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );
			//setup horizontal
			streamStartTime += 1000;
			streamSize = 18;
			//bottom hori stream
			contents += getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, cCanvasWidth,
				cCanvasHeight / 4,
				-cCanvasWidth, numberOfWaves, -heightOfWaves, percentOfHeightStraightWay, timeToCompleteWave  );


			streamStartTime += streamSize * streamSpawnDelay + timeToCompleteWave;




			topdiv.innerHTML += contents;

			return streamStartTime;
		} //end generateP2Snaking

		function getEntriesForStream( streamSize, streamStartTime, streamSpawnDelay, xStart, yStart, widthWaveDirection, numberOfWaves, heightOfWaves, pohStraightWay, timeToCompleteWave, makeItVertical  ) {
			var entry = "";
			var moveOffScreenTime = 500;
			var startTime;
			if(makeItVertical !== "makeItVertical") { makeItVertical = false; }
			else { makeItVertical = true; }

			for(var i = 0; i < streamSize; i++) {
				//spawn
				startTime = streamStartTime + (i * streamSpawnDelay);
				//exchange x and y if need to make it vertical
				if(makeItVertical) {
					entry += returnSpawnEntry(
								startTime,
								yStart, xStart );
				}
				else {
					entry += returnSpawnEntry(
								startTime,
								xStart, yStart );
				}
				//get waypoints
				var waypoints = getWaypointsForSnaking(
									xStart, yStart,
									widthWaveDirection,
									numberOfWaves,
									heightOfWaves,
									pohStraightWay, 
									startTime,
									timeToCompleteWave
									);
				//exchange x and y if need to make it vertical
				if(makeItVertical) {
					for(var mit = 0; mit < waypoints.length; mit++) {
						makeItVertical = waypoints[mit].x;
						waypoints[mit].x = waypoints[mit].y;
						waypoints[mit].y = makeItVertical;
					}
					makeItVertical = true;
				}
				//generate the move commands
				entry = addMoveCommandsGivenSnakeWaypoints( entry, waypoints);
				//get it offscreen
				if(makeItVertical) {
					entry += returnMoveToByEntry(
								(startTime + timeToCompleteWave + moveOffScreenTime ),
								parseInt(waypoints[waypoints.length-1].x) ,
								parseInt(waypoints[waypoints.length-1].y + Math.sign(widthWaveDirection) * 100)
							);
				}
				else {
					entry += returnMoveToByEntry(
								(startTime + timeToCompleteWave + moveOffScreenTime ),
								parseInt(waypoints[waypoints.length-1].x + Math.sign(widthWaveDirection) * 100),
								parseInt(waypoints[waypoints.length-1].y)
								);
				}
				entry += returnShootIntervalEntry( 1000, "amountOfShots:3,speed:200,target:player", 10  );
				//kill it
				entry += returnDieAtByEntry( startTime + timeToCompleteWave + moveOffScreenTime );

			}
			return entry;
		} //getEntriesForStream

		/**

		*/
		function addMoveCommandsGivenSnakeWaypoints( contents, smda ) {
			for ( var i = 0; i < smda.length; i++ ) {
				contents += returnMoveToByEntry(
								Math.ceil(smda[i].time),
								parseInt(smda[i].x),
								parseInt(smda[i].y)
								);
			}
			return contents;
		} 

		/**
		xStart 				usually will start on right side of screen
		yStart
		widthWaveDirection	since start on right, should be negative
		numberOfWaves
		heightOfWaves
		pohStraightWay		how much of the height should be straight travel
		timeStart 			game time to start at
		timeToCompleteWave  duration to complete the wave in.

		returns an array of objects (x,y,time)	
		*/
		function getWaypointsForSnaking( xStart, yStart, widthWaveDirection, numberOfWaves, heightOfWaves, pohStraightWay, timeStart, timeToCompleteWave  ) {
			//x distance markers
			var oneWaveDistance 	= widthWaveDirection / numberOfWaves;
			var halfWaveOpposite 	= oneWaveDistance / 2;
			var quarterWave		 	= halfWaveOpposite / 2;
			var oneSixthHalfWave 	= quarterWave / 3;
			//ydistance markers
			var straightWayDistance = heightOfWaves * pohStraightWay;
			var peakCurveDistance 	= (heightOfWaves - straightWayDistance) /2;
			
			//fuck the even speed calculation
			//somehow it came to 10 points.
			//+2 for the additional time for straightway.
			var timePerPoint 		= timeToCompleteWave / numberOfWaves / 12;

			var xWaveStart, yWaveStart, timeWaveStart;
			var moveDataBlocks = [];
			var mdb;


			//generate one whole wave, numberOfWaves times.
			//assume already at xStart,yStart
			xWaveStart = xStart;
			yWaveStart = yStart;
			timeWaveStart = timeStart;
			for ( var i = 0; i < numberOfWaves; i++ ) {
				//first generate the rest of the peak
				mdb = {};
				mdb.x = xWaveStart + oneSixthHalfWave;
				mdb.y = yWaveStart;
				mdb.time = timeWaveStart + ( timePerPoint );
				moveDataBlocks.push(mdb);
				//generate angle point
				mdb = {};
				mdb.x = xWaveStart + oneSixthHalfWave * 2;
				mdb.y = yWaveStart + peakCurveDistance;
				mdb.time = timeWaveStart + ( timePerPoint * 2 );
				moveDataBlocks.push(mdb);
				//generate first straight way
				mdb = {};
				mdb.x = xWaveStart + oneSixthHalfWave * 4;
				mdb.y = yWaveStart + peakCurveDistance + straightWayDistance;
				mdb.time = timeWaveStart + ( timePerPoint * 4 );
				moveDataBlocks.push(mdb);
				//curve of opposite peak
				mdb = {};
				mdb.x = xWaveStart + halfWaveOpposite - oneSixthHalfWave;
				mdb.y = yWaveStart + heightOfWaves;
				mdb.time = timeWaveStart + ( timePerPoint * 5 );
				moveDataBlocks.push(mdb);
				//opposite peak
				mdb = {};
				mdb.x = xWaveStart + halfWaveOpposite;
				mdb.y = yWaveStart + heightOfWaves;
				mdb.time = timeWaveStart + ( timePerPoint * 6 );
				moveDataBlocks.push(mdb);
				//opposite peak return curve start
				mdb = {};
				mdb.x = xWaveStart + halfWaveOpposite + oneSixthHalfWave;
				mdb.y = yWaveStart + heightOfWaves;
				mdb.time = timeWaveStart + ( timePerPoint * 7 );
				moveDataBlocks.push(mdb);
				//opposite peak curve
				mdb = {};
				mdb.x = xWaveStart + halfWaveOpposite + oneSixthHalfWave * 2;
				mdb.y = yWaveStart + heightOfWaves - peakCurveDistance;
				mdb.time = timeWaveStart + ( timePerPoint * 8 );
				moveDataBlocks.push(mdb);
				//return straightway
				mdb = {};
				mdb.x = xWaveStart + oneWaveDistance - oneSixthHalfWave * 2;
				mdb.y = yWaveStart + peakCurveDistance;
				mdb.time = timeWaveStart + ( timePerPoint * 10 );
				moveDataBlocks.push(mdb);
				//return curve
				mdb = {};
				mdb.x = xWaveStart + oneWaveDistance - oneSixthHalfWave;
				mdb.y = yWaveStart;
				mdb.time = timeWaveStart + ( timePerPoint * 11 );
				moveDataBlocks.push(mdb);
				//full return, start of next point
				mdb = {};
				mdb.x = xWaveStart + oneWaveDistance;
				mdb.y = yWaveStart;
				mdb.time = timeWaveStart + ( timePerPoint * 12 );
				moveDataBlocks.push(mdb);

				xWaveStart += oneWaveDistance;
				timeWaveStart += timePerPoint * 12;
			}

			return moveDataBlocks;

		} //end getWaypointsForSnaking


		/**
		=============================================================================
		=============================================================================
		=============================================================================
		*/
		function generateP1SiFormation( p1TimeOverride ) {
			var topdiv = document.getElementById("topdiv");
			var contents = "";

			var formationWidth = 8;
			var formationHeight = 9;
			var startSpawnInvTime = 7200;
			if(p1TimeOverride !== null || p1TimeOverride !== undefined) {
				startSpawnInvTime = p1TimeOverride;
			}
			var spawnIncrement = 50;
			var spawnMoveToFormationTime = 300;

			var moveDelayTime = 400; //used to calculate the startMoveInvTime
			var moveTime = 200;
			var startMoveInvTime = startSpawnInvTime + moveDelayTime + ( spawnIncrement * formationWidth * formationHeight ) + spawnMoveToFormationTime;
			var movePixelAmount = cEn1Width * 2;
			var moveCycles = 4;

			var xFormationStart;
			var yFormationStart;
			var timeReference;
			var lastDeathTime;

			for ( var w = 0; w < formationWidth; w++ ) {
				for ( var h = 0; h < formationHeight; h++ ) {
					//first spawn just off screen, but move to formation
					xFormationStart = (cCanvasWidth - (formationWidth * movePixelAmount) + (2 * cEn1Width * w));
					yFormationStart = (cEn1Width + movePixelAmount * h);
					//determine spawn time.
					timeReference = ( startSpawnInvTime + spawnIncrement * (w * formationHeight + h) );
					//spawn
					contents += returnSpawnEntry( timeReference, (cCanvasWidth + cEn1Width), yFormationStart, "visual:en3,hp:1" );
					contents += returnShootIntervalEntry(3000, "amountOfShots:1,speed:300,target:player", "mobLimited,72,1" );
					//then move
					contents += returnMoveToByEntry( ( timeReference + spawnMoveToFormationTime), xFormationStart, yFormationStart );
					//contents += returnShootAtTimeEntry(( timeReference + spawnMoveToFormationTime), "amountOfShots:1,speed:300,target:player", "100" );
					timeReference = startMoveInvTime;
					//keep it moving until off screen
					while(xFormationStart > -20) {
						//cause down movement
						contents = moveVertical( contents, moveCycles, timeReference, moveDelayTime, moveTime, xFormationStart, yFormationStart, movePixelAmount );
							//reset time counter to after completed first down
							timeReference = timeReference + ( moveCycles * moveDelayTime );
							//timeReference += moveDelayTime; //because move left;
							xFormationStart -= movePixelAmount * 2;
							yFormationStart += movePixelAmount * moveCycles;
						//move left
						contents += returnHaltUntilEntry( timeReference );
						contents += returnMoveToByEntry( timeReference + moveTime, xFormationStart, yFormationStart );
							//update time reference.
							timeReference += moveTime;
						//move up 
						contents = moveVertical( contents, moveCycles, timeReference, moveDelayTime, moveTime, xFormationStart, yFormationStart, -movePixelAmount );
							//reset counters
							timeReference = timeReference + ( moveCycles * moveDelayTime );
							//timeReference += moveDelayTime; //delay before moving left;
							xFormationStart -= movePixelAmount * 2;
							yFormationStart -= movePixelAmount * moveCycles;
						//move left 2
						contents += returnHaltUntilEntry( timeReference );
						contents += returnMoveToByEntry( timeReference + moveTime, xFormationStart, yFormationStart );
							//update time reference.
							timeReference += moveTime;
					}
					contents += returnDieAtByEntry( timeReference );

					lastDeathTime = timeReference;

					// //now get them off screen.
					// //reset counters
					// timeReference = timeReference + moveTime + ( moveCycles * moveDelayTime );
					// yFormationStart -= movePixelAmount * moveCycles;
					// //add an additional amount of upward movements until off screen.
					// //                    \/
					// var jumpsToLeave = h + 1;
					// for ( var i = 0; i < jumpsToLeave; i++ ) {
					// 	contents += "\"" + (timeReference + (i * moveDelayTime))
					// 		+ " &#09; | haltUntil\",<br>";
					// 	contents += "\"" + (timeReference + moveTime +  (i * moveDelayTime))
					// 		+ "&#09; | moveToBy &#09; | "
					// 		+ xFormationStart //x
					// 		+ "&#09; |"
					// 		+ (yFormationStart - movePixelAmount * (i + 1)) //y
					// 		+ "\",<br>";
					// }
					// contents += "\"" + (timeReference + (jumpsToLeave * moveDelayTime)) 
					// 	+ "&#09; | dieAt\",<br>";
					// lastDeathTime = (timeReference + (jumpsToLeave * moveDelayTime));
				} //end for height
			} //end for width;

			topdiv.innerHTML += contents;

			return lastDeathTime;

		} //end generateP1SiFormation

		function moveVertical(contents, moveCycles, startMoveInvTime, moveDelayTime, moveTime, xFormationStart, yFormationStart, movePixelAmount) {
			for(var i = 0; i < moveCycles; i++) {
				contents += "\"" + (startMoveInvTime + (i * moveDelayTime))
					+ " &#09; | haltUntil\",<br>";
				contents += "\"" + (startMoveInvTime + moveTime +  (i * moveDelayTime))
					+ "&#09; | moveToBy &#09; | "
					+ xFormationStart //x
					+ "&#09; |"
					+ (yFormationStart + movePixelAmount * (i + 1)) //y
					+ "\",<br>";
			} //end moving up

			return contents;
		} //end moveVertical


		function returnShootAtTimeEntry(time, type, percent) {
			if(percent === undefined || percent === null) {
				percent = "100";
			}
			if(type === undefined || type === null) {
				type = "amountOfShots:1,speed:80,target:player";
			}

			var entry = "\"" + time
				+ " &#09; | shootAtTime &#09; | "
				+ type
				+ " &#09; | "
				+ percent + "\",<br>";
			return entry;

		}

		function returnShootIntervalEntry(time, type, percent) {
			if(percent === undefined || percent === null) {
				percent = "100";
			}
			if(type === undefined || type === null) {
				type = "amountOfShots:1,speed:80,target:player";
			}

			var entry = "\"" + time
				+ " &#09; | shootInterval &#09; | "
				+ type
				+ " &#09; | "
				+ percent + "\",<br>";
			return entry;
		}

		function returnDieAtByEntry( time ) {
			var entry = "\"" + time
				+ " &#09; | dieAt\",<br>";
			return entry;
		}
		function returnHaltUntilEntry( time ) {
			var entry =  "\"" + time + " &#09; | haltUntil\",<br>";
			return entry;
		}
		function returnMoveToByEntry( time, x,y ) {
			var entry = "\"" + time
				+ " &#09; | moveToBy &#09; | "
				+ x
				+ " &#09; | "
				+ y + "\",<br>";
			return entry;
		}
		function returnSpawnEntry( time, x,y, type ) {
			if(type === undefined || type === null) {
				type = "visual:en3,hp:1";
			}

			var entry = "\"" + time
				+ " &#09; | spawn &#09; | "
				+ x
				+ " &#09; | "
				+ y 
				+ " &#09; | "
				+ type + "\",<br>";
			return entry;
		}

		/**
		=============================================================================
		=============================================================================
		=============================================================================
		*/
		function generateIntroText() {
			var topdiv = document.getElementById("topdiv");
			var contents = "";


			for(var i = 0; i < introTextPositions.length; i++) {
				var lineSplit = introTextPositions[i].split("\t");

				for(var ls = 0; ls < lineSplit.length; ls++) {
					if ( lineSplit[ls].indexOf("a") !== -1 ) {
						//spawn location based upon text format
						contents += "\"100 &#09; | spawn &#09; | "
							// right edge - (cEn1Width [size of enemy] with a buffer of 1 unit from the right)
							+ (cCanvasWidth - ( cEn1Width * ( 1 + lineSplit.length - ls ) ) )
							+ " &#09; | "
							+ ( cCanvasHeight + (cEn1Width * i) )
							+ " &#09; | visual:en3,hp:1\",<br>";
						//move like a text scroll upwards
						contents += "\"7000 &#09; | moveToBy &#09; |"
							+ (cCanvasWidth - ( cEn1Width * ( 1 + lineSplit.length - ls ) ) )
							+ " &#09; | "
							+ ( cCanvasHeight + (cEn1Width * i) - ( (introTextPositions.length + 3  ) * 2 * cEn1Width) )
							+ "\",<br>";
						//cleanup
						contents += "\"7100 &#09; | dieAt\",<br>";
					}
				}
			}

			topdiv.innerHTML += contents;


		} // end generateIntroText


		/**
		=============================================================================
		=============================================================================
		=============================================================================
		*/
		function generateStartOfVarDeclare() {
			var topdiv = document.getElementById("topdiv");
			var contents = "";
				contents += "<br>";
				contents += "var Level01Commands = [<br>";
				contents += "\"Commands must have a minimum of one separator. This will differentiate between comments, blank lines, etc.	\",<br>";
			topdiv.innerHTML = contents;
		}


		/**
		=============================================================================
		=============================================================================
		=============================================================================
		*/
		function generateEndBrace() {
			var topdiv = document.getElementById("topdiv");
			var contents = "<br>];";
			topdiv.innerHTML += contents;
		}

		</script>


		<script type="text/javascript">



var introTextPositions = [
"a				a		a	a		a			a	a		a	a	a			a		a			a	a",
"a				a		a			a			a			a		a		a		a		a		a	",
"a				a		a	a		a			a			a		a		a				a		a	a",
"a		a		a		a			a			a			a		a		a				a		a	",
"	a		a			a	a		a	a		a	a		a	a	a		a				a		a	a",
"																										",
"										a	a	a		a	a	a										",
"											a			a		a										",
"											a			a		a										",
"											a			a		a										",
"											a			a	a	a										",
"																										",
"			a	a		a	a	a		a	a	a		a	a	a				a		a				",
"			a				a			a		a		a		a			a		a		a			",
"			a	a			a			a		a		a	a				a				a			",
"				a			a			a		a		a		a			a				a			",
"			a	a			a			a	a	a		a			a		a				a			",
"																										",
"a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a	a",
"																										",
"		a	a		a	a	a			a			a	a	a	a		a	a				a			",
"		a				a			a		a		a					a				a	a			",
"		a	a			a			a	a	a		a		a	a		a	a				a			",
"			a			a			a		a		a			a		a					a			",
"	a	a			a			a		a		a	a	a	a		a	a			a	a	a	"
		];
		</script>

	</body>
</html>
